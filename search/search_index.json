{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Yuzu Inventory System","text":"<p>A powerful inventory model able to be used with built in or any other UIs Uses event based architecture</p>"},{"location":"features/","title":"Features","text":"<ul> <li>Comes with Item and Collection Systems<ul> <li>Item data easily created in Scriptable Objects</li> <li>Easily create collectibles</li> </ul> </li> <li>Stacking items<ul> <li>Smart management of stack sizes and inventory items</li> </ul> </li> <li>Drag and drop items</li> <li>Separation of UI, Model, Controller<ul> <li>Use built in UI Prefabs or create your own UI</li> </ul> </li> <li>Multiple Inventory UIs/ Hotbars</li> <li>Able to add custom logic to into item<ul> <li>Handle item usage, item auto-destroy etc.</li> </ul> </li> <li>Lots of exposed C# events to hook into</li> <li>Able to resize inventory at runtime</li> <li>Item System using Scriptable Objects</li> <li>All features compatible between different inventories<ul> <li>E.g. Able to drag and drop between 2 separate inventories</li> </ul> </li> </ul>"},{"location":"features/#todo","title":"TODO","text":"<ul> <li>Persisting data</li> </ul>"},{"location":"installation/","title":"Instructions to Add Package to Unity Project","text":"<ul> <li>In Unity, go to Windows-&gt;Package Manager</li> <li>Click the '+' button on the top left</li> <li>Select \"Add Package from Git URL\"</li> <li>Copy and Paste in <code>https://github.com/yuzhengwen/inventory-system-unity.git</code></li> <li>Click \"Add\"</li> <li>Choose Files to Import</li> <li>Done!</li> </ul>"},{"location":"item-interaction/","title":"Adding Item Interaction","text":""},{"location":"item-interaction/#built-in-class-method","title":"Built In Class Method","text":"<p>Let's say we want a health potion item. When used, it will restore health for the player. There is a built-in system for creating custom types for custom item functionality. Currently this supports item usage. In future, this may be extended to allow for item objects to receive update ticks, allow equiping etc.  </p> <p>First we create our custom HealthPotion script:</p> <pre><code>public class HealthPotionItem : BaseInventoryItem, IUseable\n{\n    private Inventory inv;\n    private Player player;\n    public HealthPotionItem(GameObject owner) : base(owner)\n    {\n        inv = owner.GetComponent&lt;Inventory&gt;();\n        player = owner.GetComponent&lt;Player&gt;();\n    }\n\n    public void Use(InventorySlot slot)\n    {\n        inv.RemoveFromSlot(slot, 1);\n        player.RestoreHealth(50);\n    }\n}\n</code></pre> <p>Here are some things to take note of:  </p> <ul> <li>For this behaviour to be recognised, it must extend from <code>BaseInventoryItem</code></li> <li>The <code>IUseable</code> interface adds the <code>Use()</code> method, which is called when user presses the 'Use' key while this item is selected</li> <li>The <code>owner</code> Game Object is passed as an argument in the constructor. This is called at runtime and provides the owner of the inventory holding the item</li> <li>It is good practice to get the references once in the inventory, and simply used the cached values in the <code>Use()</code> method</li> </ul> <p>Next, go to the Item Scriptable Object, and select this <code>HealthPotionItem</code> type in the custom behaviour type dropdown.</p> <p>And that's it! How simple is that :D</p>"},{"location":"item-interaction/#linking-from-external-script-using-events","title":"Linking From External Script Using Events","text":"<p>Let's say we have a dagger item. We want to throw a dagger projectile and decrease stack size by 1 when used  </p> <p>First we create a <code>WeaponThrower.cs</code> script.</p> <pre><code>[SerializeField] private Inventory inv;\n\nprivate void OnEnable()\n{\n    inv.OnItemUsed += ThrowWeaponFromInv;\n}\n\nprivate void OnDisable()\n{\n    inv.OnItemUsed -= ThrowWeaponFromInv;\n}\n</code></pre> <p>Here we do 2 things:</p> <ol> <li>Get a reference to our inventory data model</li> <li>Subscribe to the <code>OnItemUsed</code> event</li> </ol> <p>Next, let's handle what actually happens when an item is used. We add this method:</p> <pre><code>private void ThrowWeaponFromInv(InventorySlot slot)\n{\n    if (slot.itemData.displayName == \"Dagger\") {\n        ThrowWeapon(daggerPrefab, UtilScripts.GetVectorToMouse(throwingPoint.position));\n        slot.RemoveFromStack(1);\n    }\n}\n</code></pre> <p>Take note that the <code>OnItemUsed</code> event passes the currently selected <code>InventorySlot</code> object as an argument. Let's see how the logic is handled:</p> <ol> <li>First we check if the used item is the item we are looking for</li> <li>We call the <code>ThrowWeapon</code> function, which I will not show here, but it will instantiate a prefab in the direction given</li> <li>Lastly, it reduces stack count by 1</li> </ol> <p>If we want to consume 5 items, and only want the function to work if the stack size &gt;5, we can do a simple check on the stack size before executing our logic, then call <code>RemoveFromStack(5)</code>.</p>"},{"location":"scripting/","title":"How to use","text":""},{"location":"scripting/#backend","title":"Backend","text":"<p>Add 'Inventory' MonoBehaviour to Game Object. This has the benefit of being able to inspect inventory slots in the editor in runtime. To use, simply get a reference to the inventory object.</p>"},{"location":"scripting/#public-methods","title":"Public Methods","text":"<ul> <li><code>AddItem()</code></li> <li><code>RemoveItem()</code></li> <li><code>GetItems()</code></li> <li><code>FillSpace()</code> </li> <li><code>ClearInventory()</code></li> <li><code>PrintInventory()</code></li> <li><code>IsEmpty()</code></li> <li><code>IsFull()</code></li> </ul>"},{"location":"scripting/#events","title":"Events","text":"<ul> <li><code>OnItemAdded</code></li> <li><code>OnItemRemoved</code></li> <li><code>OnItemUsed</code></li> </ul> <p>Each event will pass in the <code>InventorySlot</code> object, which contains info about stack size, item data, custom behaviour objects.</p> <p>Since <code>InventorySlot</code> objects are passed by reference. Changing the object will directly modify the actual inventory</p>"},{"location":"scripting/#ui","title":"UI","text":""},{"location":"scripting/#adding-a-controller","title":"Adding a Controller","text":"<p>The Inventory Controller helps bridge the gap between Inventory Model and UI A single inventory can have multiple UI objects showing the inventory Items added to inventory can be controlled - Possible to add filters so that inventory only accept some items</p> <p>The <code>InventoryController</code> Class:</p> <pre><code>using InventorySystem;\nusing System;\nusing UnityEngine;\n\n[RequireComponent(typeof(Inventory))]\npublic class InventoryController : MonoBehaviour\n{\n    private Inventory inventory;\n    [SerializeField] private UI_Inventory uiInventory;\n\n    public event Action&lt;ItemDataSO&gt; OnItemCollected;\n    private void Start()\n    {\n        inventory = GetComponent&lt;Inventory&gt;();\n        uiInventory.AssignInventory(inventory);\n\n    }\n    public void AddCollectibleToInventory(ItemDataSO data)\n    {\n        inventory.AddItem(data, 1);\n        OnItemCollected?.Invoke(data);\n    }\n}\n</code></pre>"}]}